name: 'AWS EKS CI/CD Pipeline'

on:
  push:
    branches:
      - main
      - "releases/*"
    paths-ignore:
      - '**/README.md'
      - '**/.gitignore'
      - 'screenshots/**'
  pull_request:
    branches:
      - main

env:
  TF_VERSION: 1.8.1
  TF_WORKSPACE: terraform                                   # Directory where TF files exist

  TF_VAR_region: ${{ vars.AWS_REGION }}                     # AWS region
  TF_VAR_state_bucket: ${{ secrets.TF_STATE_BUCKET}}        # S3 bucket to store terraform state
  TF_VAR_name_prefix: sample-app-eks                        # The naming prefix to use for naming the created resources (ex: sample-app-eks-subnet1 )
  TF_VAR_eks_bucket: ${{ secrets.EKS_BUCKET_NAME }}         # S3 bucket for the EKS app to access
  TF_VAR_k8s_version: "1.29"                                # The kubernetes version to use for EKS
  TF_VAR_instance_type: "t3.micro"                          # The Compute engine instance type to use in EKS node pool, using here the least expensive instance type

  AWS_REGION: ${{ vars.AWS_REGION }}

jobs:
  aws_ci_cd:
    name: 'Build Infra with TF and deploy to EKS'
    runs-on: ubuntu-22.04

    defaults:
      run:
        shell: bash -e {0}

    permissions:
      contents: 'read'
      id-token: 'write'
      packages: 'write'   # needed to push docker image 

          
    steps:
    - name: Git Checkout
      uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Init and validate
      run: |
        cd $TF_WORKSPACE
        terraform init -backend-config="bucket=${TF_VAR_state_bucket}"
        terraform validate
        terraform plan
        cd -

    - name: Terraform Apply
      run: |
        terraform -chdir=${{ env.TF_WORKSPACE }} apply -auto-approve

    # Add additional steps for deploying your application, similar



    - name: Install and configure kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        aws eks update-kubeconfig --region $AWS_REGION --name $TF_VAR_name_prefix-cluster

    - name: Create MinIO credentials secret
      run: |
        kubectl create secret generic minio-credentials --from-literal=access_key=${{ secrets.AWS_ACCESS_KEY_ID }} --from-literal=secret_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Deploy MinIO
      run: |
        kubectl apply -f ./k8s-app/minio.yaml

    - name: Get the endpoint of the load balancer created for MinIO service
      run: |
        kubectl get nodes -o wide
        kubectl get svc minio-service
        # echo "Node Public IP: $(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')"
        # echo "MinIO Service Port: $(kubectl get svc minio-service -o jsonpath='{.spec.ports[0].nodePort}')"




    # k8s service is of type LoadBalancer, so it should be deleted to delete the AWS Load balancer created. Or TF destroy will fail
    - name: Sleep & then Delete MinIO Service and Terraform Destroy
      # set if: always()  In testing env, which means it will run even if previous steps fail.... 
      #  ...This is usually a good practice to clean up resources even if something goes wrong.
      if: always() 
      run: |
        sleep 900
        kubectl delete svc minio-service
        terraform -chdir=${{ env.TF_WORKSPACE }} destroy -auto-approve
